

whether the problem is dp or not -

1. can apply choices
2. optimal like max profit, min profit pucha ho 

=> overlapping problems basically recursive call hapens two times means 
in one call, we can store its result and in other no need to call that func
recursive+overlapping[memoziation] = dp

recursion + storage = DP
recursion=> memoization or top down approach


1. knapsack problems (0/1)
=> 0/1 means either choose that item or not. can't choose semi items value
=> fractional means fraction le skte hai for any item
=> unbounded means u can choose that item any number of items. ek h item k 100 bar choose kr lo
no boundation whereas in 0/1 and fractional, only 1 item choose 1 time


2. how to code dp problem
=> base condition  = think of its valid smalledst input like no items
=> choice diagram code
=> call recursive function -> with smallest ip everytime...if calling by n then next time n-1 then 
n-2 so on

try to visualize recursion. i visualized at knapsack-> try to think 2 elements, 1, 4[and weight 4]
then visualize how 4 answer comes. check aditya's videos as well


memoization dec complexity
1. nxm matrix. n and m are those who are changing like in knapsack, n (items) and weight is changing
so nxm would be ur items and weight
top down approach is better as recursive calls are not there
> n+1 , w+1 because we need to save base condition result in an array. for n=0 and
w=0 what would be the answer. if n is
5 then n+1 initialize and end result[n+1][w+1] would be res means for 5 element and sum
11 answer we can take out[bottom right corner]

2. unbounded knapsack
in this, we can choose same items multiple times. like [2,1,3] now in 0/1 knapsack,
we include 2 only once, eithre include or not or if include then dubara we dont consider ite
but, in unbounded, 2 can be taken multiple times

DP notes - 
1. think of smaller input
2. when no input then think
3. recursion solve then make it top down as top down is just application of recursion(i guess)


// think of single element of array jaise if we think subsets then think if we are picking it
then going to next then also we find answer by not picking toh ek elem k dekho

memo k bad knapsack k time complexity hta h n*w (depth*width) - n i no of elem and weight kita hai
 and space o(n*w) + stacko(n)

 # listen to solve problm using backtracking/dp..think of one entity[eg shopping offers]
 # whether to take it or not...kya ise le bhi skte hai so
 # us criteria k likho if (something something like in this we are checking any 
 # entity should not come below 0) then take it and also compute answer by not taking
 # then min of both...here make recursion tree for the same..it helps better in visualiztn
 # here at last base case thda interestng tha usually we think..pura jab h jaega toh
 # return 0 or something but here price k sath calc kia....now backtracking and
 # isme ye diff hta ki hm res maintain krte hai ..here hm ans return krate rehte h at every step
 # backtrack me end me we gather ans but here return return se ans banatae h
 # isme memo ka jab socho toh check recursion and dynamic params usme h banaega memo
 # and in this way memo kro dynamic param pe..interestng thing we should memo using
 # array and dict